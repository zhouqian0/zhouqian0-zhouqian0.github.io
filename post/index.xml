<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zhouqian Blog</title>
    <link>https://zhouqian0.github.io/post/</link>
    <description>Recent content in Posts on Zhouqian Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://zhouqian0.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二叉树的最大深度</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/104/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/104/</guid>
      <description>力扣 104. 二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的</description>
    </item>
    
    <item>
      <title>二叉树的最小深度</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/111/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/111/</guid>
      <description>力扣 111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的</description>
    </item>
    
    <item>
      <title>子集</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/78/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/78/</guid>
      <description>力扣 78. 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 方案</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/46/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/46/</guid>
      <description>力扣 46. 组合 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 方案一：递归，遍历每一种可能。 func permute(nums []int) (ans [][]int) { n := len(nums) //</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/77/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/77/</guid>
      <description>力扣 77. 组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 方案一：递归，遍历每一种可能。 func combine(n int, k int) (ans [][]int) {</description>
    </item>
    
    <item>
      <title>翻转二叉树</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/226/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/226/</guid>
      <description>力扣 226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 方案一：递归，遍历每一种可能。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left</description>
    </item>
    
    <item>
      <title>验证二叉搜索树</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/98/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/98/</guid>
      <description>力扣 98. 验证二叉搜索树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 方案一：递归，遍历每一种可能。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int</description>
    </item>
    
    <item>
      <title>三数之和</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/15/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/15/</guid>
      <description>力扣 15. 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组</description>
    </item>
    
    <item>
      <title>元素和为目标值的子矩阵数量</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/1074/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/1074/</guid>
      <description>力扣 1074. 元素和为目标值的子矩阵数量 给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。 子矩阵 x1, y1, x2, y2 是满足 x1 &amp;lt;= x &amp;lt;= x2 且 y1</description>
    </item>
    
    <item>
      <title>和为 K 的子数组</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/560/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/560/</guid>
      <description>力扣 560. 和为 K 的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。 方案一：套用优美子数组 中前缀和的方案。 func</description>
    </item>
    
    <item>
      <title>子域名访问计数</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/811/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/811/</guid>
      <description>力扣 811. 子域名访问计数 网站域名 &amp;ldquo;discuss.leetcode.com&amp;rdquo; 由多个子域名组成。顶级域名为 &amp;ldquo;com&amp;rdquo; ，二级域名为 &amp;ldquo;leetcode.com&amp;rdquo; ，最低一级为 &amp;ldquo;discuss.leetcode.com&amp;rdquo; 。当访问域名 &amp;ldquo;discuss.leetcode.com&amp;rdquo; 时，同时也会隐式访问其父域名 &amp;ldquo;leetcode.com&amp;rdquo; 以及 &amp;ldquo;com&amp;rdquo; 。</description>
    </item>
    
    <item>
      <title>数组的度</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/697/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/697/</guid>
      <description>力扣 697. 数组的度 给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。 你的任务是在 nums 中找到与 nums 拥有相</description>
    </item>
    
    <item>
      <title>盛最多水的容器</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/11/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/11/</guid>
      <description>力扣 11. 盛最多水的容器 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器</description>
    </item>
    
    <item>
      <title>两数之和 II - 输入有序数组</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/167/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/167/</guid>
      <description>力扣 167. 两数之和 II - 输入有序数组 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。</description>
    </item>
    
    <item>
      <title>最大子数组和</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/53/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/53/</guid>
      <description>力扣 1109. 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部</description>
    </item>
    
    <item>
      <title>航班预订统计</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/1109/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/1109/</guid>
      <description>力扣 1109. 航班预订统计 这里有 n 个航班，它们分别从 1 到 n 进行编号。 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的</description>
    </item>
    
    <item>
      <title>二维区域和检索 - 矩阵不可变</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/304/</link>
      <pubDate>Sun, 24 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/304/</guid>
      <description>力扣 304. 二维区域和检索 - 矩阵不可变 给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下</description>
    </item>
    
    <item>
      <title>统计「优美子数组」</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/1248/</link>
      <pubDate>Sun, 24 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/1248/</guid>
      <description>力扣 1248. 统计「优美子数组」 给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回</description>
    </item>
    
    <item>
      <title>LRU 缓存</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/146/</link>
      <pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/146/</guid>
      <description>力扣 146. LRU 缓存 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于</description>
    </item>
    
    <item>
      <title>两数之和</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/1/</link>
      <pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/1/</guid>
      <description>力扣 1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每</description>
    </item>
    
    <item>
      <title>串联所有单词的子串</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/30/</link>
      <pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/30/</guid>
      <description>力扣 30. 串联所有单词的子串 给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单</description>
    </item>
    
    <item>
      <title>字母异位词分组</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/49/</link>
      <pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/49/</guid>
      <description>力扣 49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的字母得到的一个</description>
    </item>
    
    <item>
      <title>模拟行走机器人</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/874/</link>
      <pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/874/</guid>
      <description>力扣 874. 模拟行走机器人 机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ： -2 ：向左转 90</description>
    </item>
    
    <item>
      <title>最大矩形</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/85/</link>
      <pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/85/</guid>
      <description>力扣 85. 最大矩形 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 方案一：类比力扣 84题，将矩阵压缩成</description>
    </item>
    
    <item>
      <title>加一</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/66/</link>
      <pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/66/</guid>
      <description>力扣 66. 加一 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以</description>
    </item>
    
    <item>
      <title>合并两个有序链表</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/21/</link>
      <pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/21/</guid>
      <description>力扣 21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 方案一：遍历双链表，通过过</description>
    </item>
    
    <item>
      <title>设计循环双端队列</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/641/</link>
      <pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/641/</guid>
      <description>力扣 641. 设计循环双端队列 设计实现双端队列。 实现 MyCircularDeque 类: MyCircularDeque(int k)：构造函数,双端队列最大为 k。 boolean insertFront()：将一个元素添加到双端队列</description>
    </item>
    
    <item>
      <title>接雨水</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/42/</link>
      <pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/42/</guid>
      <description>力扣 42. 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 方案一：垂直方向每一竖计算能接住的雨水</description>
    </item>
    
    <item>
      <title>柱状图中最大的矩形</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/84/</link>
      <pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/84/</guid>
      <description>力扣 84. 柱状图中最大的矩形 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的</description>
    </item>
    
    <item>
      <title>滑动窗口最大值</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/239/</link>
      <pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/239/</guid>
      <description>力扣 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。 你只可以看到在滑动窗口内的 k 个数字。</description>
    </item>
    
    <item>
      <title>基本计算器</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/224/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/224/</guid>
      <description>力扣 224. 基本计算器 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 注意:不允许使用任何将字符串作为数学表达式计算的内置函数，</description>
    </item>
    
    <item>
      <title>逆波兰表达式求值</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/150/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/150/</guid>
      <description>力扣 150. 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意</description>
    </item>
    
    <item>
      <title>最小栈</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/155/</link>
      <pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/155/</guid>
      <description>力扣 155. 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。</description>
    </item>
    
    <item>
      <title>有效的括号</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/20/</link>
      <pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/20/</guid>
      <description>力扣 20. 有效的括号 给定一个只包括 &amp;lsquo;(&amp;rsquo;，&amp;rsquo;)&amp;rsquo;，&amp;rsquo;{&amp;rsquo;，&amp;rsquo;</description>
    </item>
    
    <item>
      <title>环形链表</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/141/</link>
      <pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/141/</guid>
      <description>力扣 141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定</description>
    </item>
    
    <item>
      <title>环形链表 II</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/142/</link>
      <pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/142/</guid>
      <description>力扣 142. 环形链表 II 给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续</description>
    </item>
    
    <item>
      <title>邻值查找</title>
      <link>https://zhouqian0.github.io/algorithm/acwing/136/</link>
      <pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/acwing/136/</guid>
      <description>acwing 136. 邻值查找 给定一个长度为 n 的序列 A ，A 中的数各不相同。 对于 A 中的每一个数 Ai ，求： min1≤j&amp;lt;i|Ai−Aj| 以及令上式取到最小值的</description>
    </item>
    
    <item>
      <title>K 个一组翻转链表</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/25/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/25/</guid>
      <description>力扣 25. K 个一组翻转链表 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点</description>
    </item>
    
    <item>
      <title>反转链表</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/206/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/206/</guid>
      <description>力扣 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 方案一：通过过滤器将所有非零元素顺序前置。 /** * Definition for singly-linked list. * type ListNode struct { * Val int</description>
    </item>
    
    <item>
      <title>删除有序数组中的重复项</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/26/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/26/</guid>
      <description>力扣 26. 删除有序数组中的重复项 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺</description>
    </item>
    
    <item>
      <title>合并两个有序数组</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/88/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/88/</guid>
      <description>力扣 88. 合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使</description>
    </item>
    
    <item>
      <title>移动零</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/283/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/283/</guid>
      <description>力扣 283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数</description>
    </item>
    
    <item>
      <title>Linux 日常命令 — find</title>
      <link>https://zhouqian0.github.io/2022/05/25/linux/find/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/2022/05/25/linux/find/</guid>
      <description>介绍 find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。 如果使用该命令时，不设置任何参数，则 find 命令将在当前目录</description>
    </item>
    
    <item>
      <title>工作区和GOPATH</title>
      <link>https://zhouqian0.github.io/2022/05/25/install-source/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/2022/05/25/install-source/</guid>
      <description>环境介绍 通过 docker image 创建的 container。 通过命令 docker run -it golang 启动容器。 容器使用 Go 版本：v1.18.2 linux/amd64 GOROOT GO 语言的安装路径。 GOPATH Go 的工作目录，值为</description>
    </item>
    
    <item>
      <title>Linux 日常命令 — df</title>
      <link>https://zhouqian0.github.io/2022/05/18/linux/df/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/2022/05/18/linux/df/</guid>
      <description>介绍 df（disk free）：用于显示在 Linux 系统上的文件系统磁盘使用情况统计。 如果命令未指定目录，则默认展示当前被挂载的文件系统的可用空间（单</description>
    </item>
    
    <item>
      <title>Linux 日常命令 — du</title>
      <link>https://zhouqian0.github.io/2022/05/18/linux/du/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/2022/05/18/linux/du/</guid>
      <description>介绍 du（disk usage）：用于显示指定的目录或文件所占用的磁盘空间。 如果命令未指定目录，则默认展示当前目录的文件磁盘使用情况（单位 kb</description>
    </item>
    
    <item>
      <title>Linux 磁盘占用分析</title>
      <link>https://zhouqian0.github.io/2022/05/18/disk/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/2022/05/18/disk/</guid>
      <description>磁盘相关命令 df du 大文件占用查找思路 使用 df -Th 找到希望查找的目录中磁盘占用最大的目录。 [root@iZuf6cdrrzbsjtp7kwq6haZ ~]# df -Th Filesystem Type Size Used Avail Use% Mounted on devtmpfs devtmpfs 387M 0 387M 0% /dev tmpfs tmpfs 405M 0 405M 0% /dev/shm tmpfs tmpfs 405M</description>
    </item>
    
    <item>
      <title>Go 语言介绍</title>
      <link>https://zhouqian0.github.io/2022/05/17/intro/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/2022/05/17/intro/</guid>
      <description>Go 语言简介 Go 语言是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 Go 语言优势 可以用作构建快速、可靠、高效的规模化软件，</description>
    </item>
    
  </channel>
</rss>
