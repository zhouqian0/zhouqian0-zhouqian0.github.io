<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursion on Zhouqian Blog</title>
    <link>https://zhouqian0.github.io/tags/recursion/</link>
    <description>Recent content in recursion on Zhouqian Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://zhouqian0.github.io/tags/recursion/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二叉树的最大深度</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/104/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/104/</guid>
      <description>力扣 104. 二叉树的最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的</description>
    </item>
    
    <item>
      <title>二叉树的最小深度</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/111/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/111/</guid>
      <description>力扣 111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的</description>
    </item>
    
    <item>
      <title>子集</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/78/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/78/</guid>
      <description>力扣 78. 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 方案</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/46/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/46/</guid>
      <description>力扣 46. 组合 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 方案一：递归，遍历每一种可能。 func permute(nums []int) (ans [][]int) { n := len(nums) //</description>
    </item>
    
    <item>
      <title>组合</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/77/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/77/</guid>
      <description>力扣 77. 组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 方案一：递归，遍历每一种可能。 func combine(n int, k int) (ans [][]int) {</description>
    </item>
    
    <item>
      <title>翻转二叉树</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/226/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/226/</guid>
      <description>力扣 226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 方案一：递归，遍历每一种可能。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left</description>
    </item>
    
    <item>
      <title>验证二叉搜索树</title>
      <link>https://zhouqian0.github.io/algorithm/leetcode/98/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhouqian0.github.io/algorithm/leetcode/98/</guid>
      <description>力扣 98. 验证二叉搜索树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 方案一：递归，遍历每一种可能。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int</description>
    </item>
    
  </channel>
</rss>
